package com.itech.itech_backend.modules.search.service;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
import co.elastic.clients.elasticsearch._types.query_dsl.*;
import co.elastic.clients.elasticsearch.core.*;
import co.elastic.clients.elasticsearch.core.search.Hit;
import com.itech.itech_backend.modules.search.dto.SearchRequest;
import com.itech.itech_backend.modules.search.dto.SearchResponse;
import com.itech.itech_backend.modules.search.model.ProductDocument;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SearchService {

    private final ElasticsearchClient elasticsearchClient;
    private static final String PRODUCTS_INDEX = "products";

    public SearchResponse<ProductDocument> searchProducts(SearchRequest request, Pageable pageable) {
        try {
            // Build query
            BoolQuery.Builder queryBuilder = QueryBuilders.bool();

            // Add text search if query is present
            if (request.getQuery() != null && !request.getQuery().isBlank()) {
                queryBuilder.must(QueryBuilders.multiMatch()
                        .fields("name^3", "description", "brandName", "tags")
                        .query(request.getQuery())
                        .fuzziness("AUTO")
                        .build()._toQuery());
            }

            // Add filters
            addFilters(queryBuilder, request);

            // Execute search
            SearchResponse<ProductDocument> response = elasticsearchClient.search(s -> s
                    .index(PRODUCTS_INDEX)
                    .query(queryBuilder.build()._toQuery())
                    .from(pageable.getPageNumber() * pageable.getPageSize())
                    .size(pageable.getPageSize())
                    .sort(getSortBuilders(request))
                    .aggregations(getAggregations())
                    .highlight(h -> h
                        .fields("name", f -> f
                            .preTags("<em>")
                            .postTags("</em>")
                        )
                    ), ProductDocument.class);

            // Extract results
            List<ProductDocument> products = response.hits().hits().stream()
                    .map(Hit::source)
                    .collect(Collectors.toList());

            // Extract aggregations
            Map<String, Map<String, Long>> aggregations = parseAggregations(response);

            // Create page
            Page<ProductDocument> page = new PageImpl<>(
                products,
                pageable,
                response.hits().total().value()
            );

            return new SearchResponse<>(page, aggregations);

        } catch (IOException e) {
            log.error("Error executing search", e);
            throw new RuntimeException("Search failed", e);
        }
    }

    private void addFilters(BoolQuery.Builder queryBuilder, SearchRequest request) {
        // Price range filter
        if (request.getMinPrice() != null || request.getMaxPrice() != null) {
            RangeQuery.Builder priceRange = QueryBuilders.range()
                    .field("price");
            if (request.getMinPrice() != null) {
                priceRange.gte(JsonData.of(request.getMinPrice()));
            }
            if (request.getMaxPrice() != null) {
                priceRange.lte(JsonData.of(request.getMaxPrice()));
            }
            queryBuilder.filter(priceRange.build()._toQuery());
        }

        // Categories filter
        if (request.getCategories() != null && !request.getCategories().isEmpty()) {
            queryBuilder.filter(QueryBuilders.terms()
                    .field("categories")
                    .terms(t -> t.value(request.getCategories().stream()
                            .map(JsonData::of)
                            .collect(Collectors.toList())))
                    .build()._toQuery());
        }

        // Brand filter
        if (request.getBrands() != null && !request.getBrands().isEmpty()) {
            queryBuilder.filter(QueryBuilders.terms()
                    .field("brandName")
                    .terms(t -> t.value(request.getBrands().stream()
                            .map(JsonData::of)
                            .collect(Collectors.toList())))
                    .build()._toQuery());
        }

        // Location filters
        if (request.getCity() != null && !request.getCity().isBlank()) {
            queryBuilder.filter(QueryBuilders.term()
                    .field("city")
                    .value(request.getCity())
                    .build()._toQuery());
        }
        if (request.getState() != null && !request.getState().isBlank()) {
            queryBuilder.filter(QueryBuilders.term()
                    .field("state")
                    .value(request.getState())
                    .build()._toQuery());
        }

        // Stock filter
        if (request.getInStockOnly()) {
            queryBuilder.filter(QueryBuilders.term()
                    .field("inStock")
                    .value(true)
                    .build()._toQuery());
        }

        // Rating filter
        if (request.getMinRating() != null) {
            queryBuilder.filter(QueryBuilders.range()
                    .field("rating")
                    .gte(JsonData.of(request.getMinRating()))
                    .build()._toQuery());
        }

        // Specification filters
        if (request.getSpecifications() != null && !request.getSpecifications().isEmpty()) {
            request.getSpecifications().forEach((key, values) -> {
                if (values != null && !values.isEmpty()) {
                    queryBuilder.filter(QueryBuilders.nested()
                            .path("specifications")
                            .query(q -> q.bool(b -> b
                                    .must(QueryBuilders.term()
                                            .field("specifications.name")
                                            .value(key)
                                            .build()._toQuery())
                                    .must(QueryBuilders.terms()
                                            .field("specifications.value")
                                            .terms(t -> t.value(values.stream()
                                                    .map(JsonData::of)
                                                    .collect(Collectors.toList())))
                                            .build()._toQuery())))
                            .build()._toQuery());
                }
            });
        }
    }

    private List<SortOptions> getSortBuilders(SearchRequest request) {
        List<SortOptions> sortBuilders = new ArrayList<>();
        
        if ("price".equals(request.getSortBy())) {
            sortBuilders.add(SortOptions.of(s -> s
                    .field(f -> f
                            .field("price")
                            .order(request.getSortOrder()))));
        } else if ("rating".equals(request.getSortBy())) {
            sortBuilders.add(SortOptions.of(s -> s
                    .field(f -> f
                            .field("rating")
                            .order(request.getSortOrder()))));
        } else if ("createdAt".equals(request.getSortBy())) {
            sortBuilders.add(SortOptions.of(s -> s
                    .field(f -> f
                            .field("createdAt")
                            .order(request.getSortOrder()))));
        }
        
        return sortBuilders;
    }

    private Map<String, Aggregation> getAggregations() {
        Map<String, Aggregation> aggregations = new HashMap<>();
        
        // Category aggregation
        aggregations.put("categories", Aggregation.of(a -> a
                .terms(t -> t.field("categories"))));
        
        // Brand aggregation
        aggregations.put("brands", Aggregation.of(a -> a
                .terms(t -> t.field("brandName"))));
        
        // Price range aggregation
        aggregations.put("priceRanges", Aggregation.of(a -> a
                .range(r -> r
                        .field("price")
                        .ranges(
                            r1 -> r1.to("1000").key("Under ₹1,000"),
                            r1 -> r1.from("1000").to("5000").key("₹1,000 - ₹5,000"),
                            r1 -> r1.from("5000").to("10000").key("₹5,000 - ₹10,000"),
                            r1 -> r1.from("10000").key("Above ₹10,000")
                        ))));
        
        // Location aggregations
        aggregations.put("cities", Aggregation.of(a -> a
                .terms(t -> t.field("city"))));
        aggregations.put("states", Aggregation.of(a -> a
                .terms(t -> t.field("state"))));
        
        // Rating aggregation
        aggregations.put("ratings", Aggregation.of(a -> a
                .range(r -> r
                        .field("rating")
                        .ranges(
                            r1 -> r1.from("4").key("4+ Stars"),
                            r1 -> r1.from("3").to("4").key("3-4 Stars"),
                            r1 -> r1.from("2").to("3").key("2-3 Stars"),
                            r1 -> r1.to("2").key("Below 2 Stars")
                        ))));
        
        return aggregations;
    }

    private Map<String, Map<String, Long>> parseAggregations(SearchResponse<ProductDocument> response) {
        Map<String, Map<String, Long>> result = new HashMap<>();
        
        response.aggregations().forEach((name, agg) -> {
            Map<String, Long> buckets = new HashMap<>();
            
            if (agg.isSterms()) {
                agg.sterms().buckets().array().forEach(bucket ->
                    buckets.put(bucket.key(), bucket.docCount()));
            } else if (agg.isRange()) {
                agg.range().buckets().array().forEach(bucket ->
                    buckets.put(bucket.key(), bucket.docCount()));
            }
            
            result.put(name, buckets);
        });
        
        return result;
    }

    public void indexProduct(ProductDocument product) {
        try {
            elasticsearchClient.index(i -> i
                    .index(PRODUCTS_INDEX)
                    .id(product.getId())
                    .document(product));
        } catch (IOException e) {
            log.error("Error indexing product", e);
            throw new RuntimeException("Failed to index product", e);
        }
    }

    public void deleteProduct(String productId) {
        try {
            elasticsearchClient.delete(d -> d
                    .index(PRODUCTS_INDEX)
                    .id(productId));
        } catch (IOException e) {
            log.error("Error deleting product", e);
            throw new RuntimeException("Failed to delete product", e);
        }
    }

    public void bulkIndex(List<ProductDocument> products) {
        try {
            BulkRequest.Builder br = new BulkRequest.Builder();
            
            for (ProductDocument product : products) {
                br.operations(op -> op
                        .index(idx -> idx
                                .index(PRODUCTS_INDEX)
                                .id(product.getId())
                                .document(product)));
            }
            
            BulkResponse response = elasticsearchClient.bulk(br.build());
            
            if (response.errors()) {
                log.error("Bulk indexing had errors: {}", 
                        response.items().stream()
                                .filter(item -> item.error() != null)
                                .map(item -> item.error().reason())
                                .collect(Collectors.joining(", ")));
            }
        } catch (IOException e) {
            log.error("Error bulk indexing products", e);
            throw new RuntimeException("Failed to bulk index products", e);
        }
    }
}
